#' Inform the user of the number of variables matched
#'
#' @keywords Internal
#'
#' @importFrom glue glue
#' @importFrom cli cli_inform
inform_var_count <- function(data) {
  var_count_msg <- glue("Matching {length(data)} variables...")
  cli_inform(var_count_msg)
}

#' N sizes to display in crosstabs
#'
#' @keywords Internal
n_table <- function(data, var, among = NULL) {
  quo_var <- enquo(var)
  quo_among <- enquo(among)

  if (!quo_is_null(quo_among)) {
    data <- data %>%
      filter(!is.na(!!quo_among))
  }

  data %>%
    # `select`, rather than `pull`, is important
    # because the output of `table` is named after `var`
    # when selecting, but not when pulling
    select(!!quo_var) %>%
    table(useNA = "always") %>%
    as_tibble()
}


#' Unweighted percentages for response options on a single variable
#'
#' @importFrom rlang enquo as_name
#' @importFrom dplyr pull rename
#' @importFrom pewmethods get_totals
#' @importFrom tibble as_tibble
#'
#' @export
totals <- function(data, var, na.rm = FALSE, digits = 2, complete = TRUE) {
  quo_var <- enquo(var)
  chr_var <- quo_var %>% as_name()
  var <- data %>% pull(!!quo_var)
  if (!is.factor(var)) stop("`var` must be a factor")

  out <- get_totals(
    var = chr_var,
    df = data,
    digits = digits,
    complete = complete,
    na.rm = na.rm
  ) %>%
    rename(value = unweighted) %>%
    as_tibble()

  return(out)
}

#' Unweighted percentages for response options on a single variable, split
#' by a second
#'
#' @importFrom dplyr select
#'
#' @export
totals_by <- function(
  data,
  var,
  by,
  na.rm = FALSE,
  digits = 2,
  complete = TRUE
) {
  quo_var <- enquo(var)
  chr_var <- quo_var %>% as_name()
  quo_by <- enquo(by)
  chr_by <- quo_by %>% as_name()
  var <- data %>% pull(!!quo_var)
  by <- data %>% pull(!!quo_by)
  if (!is.factor(var)) stop("`var` must be a factor")
  if (!is.factor(by)) stop("`by` must be a factor")

  out <- pewmethods::get_totals(
    var = chr_var,
    df = data,
    by = chr_by,
    digits = digits,
    complete = complete,
    na.rm = na.rm
  ) %>%
    select(-weight_name) %>%
    as_tibble()

  return(out)
}


#' Unweighted percentages for response options on multiple variables
#'
#' @importFrom tidyselect matches
#' @importFrom purrr set_names map
#' @importFrom rlang sym
#'
#' @export
totals_list <- function(
  data,
  vars,
  na.rm = FALSE,
  digits = 2,
  complete = TRUE
) {
  criteria <- enquo(vars)

  new_data <- data %>%
    select(!!criteria)

  inform_var_count(new_data)

  new_data %>%
    names() %>%
    purrr::set_names() %>%
    map(
      ~ .x %>%
        sym() %>%
        {
          totals(data, !!., na.rm = na.rm, digits = digits, complete = complete)
        } %>%
        rename(level = .x)
    )
}

#' Unweighted crosstab of one variable by another
#'
#' The transpose of `totals_by`, which tends be more readable
#'
#' For now, na.rm = FALSE is required for getting accurate distributions, since
#' the `n` column provides raw n for when missing values are included.
#'
#' @importFrom tidyselect everything
#' @importFrom tidyr pivot_wider pivot_longer
#' @importFrom dplyr left_join
#'
#' @export
crosstab <- function(
  data,
  var,
  by,
  na.rm = FALSE,
  digits = 2,
  complete = TRUE
) {
  quo_var <- enquo(var)
  quo_by <- enquo(by)
  chr_by <- quo_by %>% as_name()

  n_table <- n_table(data, var = !!quo_by, among = !!quo_var)

  totals_by(
    data,
    !!quo_var,
    !!quo_by,
    na.rm = na.rm,
    digits = digits,
    complete = complete
  ) %>%
    pivot_longer(
      cols = c(everything(), -!!quo_var),
      names_to = "level",
      values_to = "value"
    ) %>%
    pivot_wider(names_from = !!quo_var, values_from = value) %>%
    left_join(n_table, by = c("level" = chr_by))
}


#' Unweighted crosstab of multiple variables by one crossing variable
#'
#' @export
crosstab_list <- function(
  data,
  vars,
  by,
  na.rm = FALSE,
  digits = 2,
  complete = TRUE
) {
  criteria <- enquo(vars)
  quo_by <- enquo(by)

  new_data <- data %>%
    select(!!criteria)

  inform_var_count(new_data)

  new_data %>%
    names() %>%
    purrr::set_names() %>%
    map(
      ~ .x %>%
        sym() %>%
        {
          crosstab(
            data,
            !!.,
            by = !!quo_by,
            na.rm = na.rm,
            digits = digits,
            complete = complete
          )
        }
    )
}


#' Frequency distribution of a variable, a la SPSS
#'
#' We don't allow the `na.rm` argument (as in, we force na.rm = TRUE)
#' because of the point of the table: to display "valid percentages" (borrowing
#' that language from SPSS) next to the raw n values generated by `table`. Raw
#' n for `NA` is still provided, but with no percentage attached.
#'
#' Because `complete` is a `get_totals` parameter, it has no effect on which levels
#' get raw n values from `table`. Raw n's will be generated for all levels, unless
#' we add functionality for `complete` to affect both raw n's and percentages.
#' For now, we force `complete = TRUE` so that we get percentages 0-n values.
#'
#' @export
#'
#' @importFrom dplyr mutate full_join filter
#' @importFrom purrr map_dfc
#' @importFrom tibble add_row
spss_freq <- function(data, var, digits = 2) {
  quo_var <- enquo(var)
  chr_var <- quo_var %>% as_name()

  table_df <- table(data[[chr_var]], useNA = "ifany") %>%
    as.data.frame() %>%
    as_tibble() %>%
    rename(!!quo_var := Var1, frequency = Freq)

  totals_df <- totals(
    data,
    !!quo_var,
    na.rm = TRUE,
    digits = digits,
    complete = TRUE
  ) %>%
    rename(percent = value) %>%
    mutate(cumul_percent = cumsum(percent))

  out <- table_df %>%
    full_join(totals_df, by = chr_var)

  total_full_row <- out %>%
    select(-!!quo_var, -cumul_percent) %>%
    map_dfc(sum) %>%
    mutate(!!quo_var := "TOTAL - full")

  # if no NAs, dont worry, proceed
  if (table_df %>% filter(is.na(!!quo_var)) %>% nrow() == 0) {
    out %>%
      add_row(total_full_row)
  } else {
    # if there are NAs to consider, the table should have extra rows
    total_valid_row <- out %>%
      filter(!is.na(!!quo_var)) %>%
      select(-!!quo_var, -cumul_percent) %>%
      map_dfc(sum) %>%
      mutate(!!quo_var := "TOTAL - valid")

    (out %>% filter(!is.na(!!quo_var))) %>%
      add_row(total_valid_row) %>%
      add_row(out %>% filter(is.na(!!quo_var))) %>%
      add_row(total_full_row)
  }
}

#' Calculate Battery Totals
#'
#' This function calculates the totals for specific variables within a dataset, based on a given battery identifier. It extracts the relevant variables, computes totals, and filters them according to specified criteria.
#'
#' @param data A data frame
#' @param batt A character string representing the battery identifier used to find relevant variables within the dataset.
#' @param value_to_find A character string representing the value to filter the totals by. Default is `"Selected"`.
#' @param label_regex A regular expression, used to extract labels from variable attributes. Default is `"(?<=:).*"` which extracts all text following a colon.
#'
#' @return A data frame containing the item labels and their corresponding total values.
#'
#' @details Filters the results to include only those with a specified value. 
#' It also extracts item labels based on a regular expression pattern. 
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' result <- batt_totals(data = my_data, batt = "Q23")
#' }
#'
#' @import dplyr
#' @import purrr
#' @import stringr
#' @importFrom rlang sym
#'
#' @export
batt_totals <- function(
  data,
  batt,
  value_to_find = "Selected",
  label_regex = "(?<=:).*$"
) {
  vars <- find_vars(data, batt)

  out <- vars %>%
    purrr::set_names() %>%
    map(function(x) {
      sym_var <- sym(x)
      out <- totals(
        data,
        !!sym_var,
        digits = 0,
        complete = TRUE,
        na.rm = TRUE
      ) %>%
        filter(!!sym_var == value_to_find) %>%
        rename(level = !!sym_var)
    }) %>%
    bind_rows(.id = "var")
  
  # at this point, if `value_to_find` is not a level of any `vars`,
  # then `out` will have nrow = 0, which is bad
  
  if (nrow(out) == 0) {
    rlang::abort(glue("'{value_to_find}' is not a level in the variables matching '{batt}'"))
  }
  
  out <- out %>% 
    rowwise() %>%
    mutate(
      item = data[[var]] %>% attr("label") %>% str_extract(label_regex)
    ) %>%
    select(item, value)

  out
}
